int n, t[4*MAXN];
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = t[v*2] + t[v*2+1];
    }
}

int sum(int v, int tl, int tr, int l, int r) {
    if (l > r) 
        return 0;
    if (l == tl && r == tr) {
        return t[v];
    }
    int tm = (tl + tr) / 2;
    return sum(v*2, tl, tm, l, min(r, tm))
           + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
}

void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val);
        else
            update(v*2+1, tm+1, tr, pos, new_val);
        t[v] = t[v*2] + t[v*2+1];
    }
}

int mod = 1e9 + 7;
class segTree {
public:
	vector<int> tree;
	int N = 0;
	void build(int n, vector<int> &a) {
		while(__builtin_popcount(n) != 1) {
			n++;
		}
		tree.resize(2 * n);
		for(int i = 0; i < a.size(); i++) {
			tree[n + i] = a[i];
		}
		for(int i = n - 1; i > 0; i--) {
			tree[i] = (tree[2 * i] + tree[2 * i + 1]) % mod;
		}
		N = n;
	}
    segTree(vector<int>& a) {
        build(a.size(), a);
    }
    void update(int ind, int val) {
		ind += N;
		tree[ind] = val;
		ind /= 2;
		while(ind > 0) {
			tree[ind] = tree[2 * ind] + tree[2 * ind + 1];
			ind /= 2;
		}
	}
    int sum(int i, int l, int r, int ql, int qr) {
		if(qr < l || ql > r) {
			return 0;
		}
		if(ql == l && r == qr) {
			return tree[i];
		}
		int mid = (l + r) / 2;
		return (sum(2 * i, l, mid, ql, min(qr, mid)) + sum(2 * i + 1, mid + 1, r, max(ql, mid + 1), qr)) % mod;
	}
    int sumRange(int left, int right) {
        return sum(1, 0, N - 1, left, right);
    }
};
